const Product = require("../models/product");
const APIFeatures = require("../utilities/utilities");
const dotenv = require("dotenv");
const fs = require("fs");
dotenv.config({ path: `${__dirname}../config.env` });

//status messages and error hanlding
const statusMessages = require("../status");
const catchAsyncFunction = require("../utilities/catchAsync");
const AppError = require("../utilities/appError");
//
const JWT_SECRET = process.env.JWT_SECRET;
const { status } = statusMessages();

//Adding products to the store
const createProducts = catchAsyncFunction(async (req, res) => {
	/* 
	A post to create and add an item to the store  
	Extenstion refers to the category of the item
	*/
	const product = await Product.create(req.body);
	res.json({ status: status.success, data: product });
});
///////////////////////
/*GET PRODUCTS ALIAS */
///////////////////////
const categorySelect = catchAsyncFunction(async (req, res, next) => {
	//TODO encode req param so that it is useable in url
	//TODO make so that it will get mult
	req.query.limit = 25;
	req.query.page = 1;
	req.query.fields = "name, price, extension, count, img, text";
	req.query.extension = req.params.extension;
	next();
});

///////////////////////
///////////////////////
//PRIMARY GET FUNCTION FOR PRODUCTS!
const getProducts = catchAsyncFunction(async (req, res, next) => {
	const query = await new APIFeatures(Product, req.query)
		.filter()
		.sort()
		.fields()
		.pagenation();

	// 1 ) Query Execution
	const data = await query.query;

	/// ERROR A ) Falsy value generated by APIFeatures
	if (!data || data.length < 1) {
		return next(
			new AppError("No information is found with those query params!", 404)
		);
	}

	// 2 ) Data Response
	return res.status(200).json({ status: status.success, data: data });
});

const patchProducts = catchAsyncFunction(async (req, res, next) => {
	const product = await Product.findByIdAndUpdate(req.params.id, req.body, {
		new: true,
		runValidators: true,
	});
	res.status(200).json({ status: status.success, data: product });
});

const deleteProducts = catchAsyncFunction(async (req, res, next) => {
	await Product.findByIdAndDelete(req.params.id);
	res.status(200).json({
		status: status.success,
		data: null,
	});
});

//! DEVTOOL
const massPopulateDev = async (req, res, next) => {
	try {
		fs.readFile(
			`${__dirname}/../../frontend/src/assets/rampage.json`,
			(err, data) => {
				console.log(data);
				data = JSON.parse(data);
				data.forEach(async (product, index) => {
					const params = {
						name: product.name,
						img: product.ultra_url_path,
						text: product.text,
						count: product.count,
						extension: product.extension,
						price: product.price * 1,
					};
					await Product.create(params);
					return;
				});
				res.json({ success: "yay" });
			}
		);
	} catch (err) {
		console.log("poop");
	}
};
//! DEVTOOL
const setExtensionsDev = catchAsyncFunction(async (req, res, next) => {
	const fixExtensionRegexp = /\s/gi;
	const products = await Product.find();
	products.forEach(async (product) => {
		//EDIT FIELDS HERE!
		product.extension = product.extension.replace(fixExtensionRegexp, "-");
		product.extension = product.extension.toLowerCase();
		return await Product.findByIdAndUpdate(product.id, {
			extension: product.extension,
		});
	});
	res.json({
		status: "SUCCESS",
		message: "YOUR FILE HAS BEEN PATCHED",
		data: products,
	});
});

const getPriceAverage = catchAsyncFunction(async (req, res, next) => {
	const stats = await Product.aggregate([
		{
			$match: { price: { $gte: 1 } },
		},
		{
			$group: {
				_id: null,
				avgPrice: { $avg: "$price" },
				maxPrice: { $max: "$price" },
				minPrice: { $min: "$price" },
			},
		},
	]);
	res.status(200).json({ message: status.success, data: stats });
});

const model = {
	getProducts,
	createProducts,
	patchProducts,
	deleteProducts,
	getPriceAverage,
	categorySelect,
	massPopulateDev,
	setExtensionsDev,
};

module.exports = model;
